const Product = require("../models/Productmodel");
const logActivity = require("../libs/logger");
const { canOverrideOwner } = require("../middleware/Authmiddleware.js");
module.exports.createProduct = async (req, res) => {
  try {
    const { name, Desciption, Category, Price, quantity, image, supplier } =
      req.body;

    if (!name || !Desciption || !Category || !Price) {
      return res.status(400).json({
        message: "Please provide all required product details.",
      });
    }

    const {
      userId,
      branchId,
      countryId,
      userCurrency,
      usercurrencySymbol,
      userCurrencyExchangeRate,
    } = req.user;

    // Convert local price to USD using snapshot exchange rate
    const priceUSD = Number((Price / userCurrencyExchangeRate).toFixed(2));

    const createdProduct = new Product({
      name,
      Desciption,
      Category,
      Price,
      branchId,
      countryId,
      currency: userCurrency,
      priceUSD,
      exchangeRateUsed: userCurrencyExchangeRate,
      currencySymbol: usercurrencySymbol,
      createdBy: userId,
      quantity: quantity ?? 0,
      image,
      supplier,
      // sku is auto-generated by schema
    });

    await createdProduct.save();

    await logActivity({
      action: "Add Product",
      description: `Product "${name}" was added`,
      entity: "product",
      entityId: createdProduct._id,
      userId: userId,
      ipAddress: req.ip,
    });

    res.status(201).json({
      message: "Product created successfully",
      product: createdProduct,
    });
  } catch (error) {
    res.status(400).json({
      message: "Error in creating product",
      error: error.message,
    });
  }
};

// module.exports.getProduct = async (req, res) => {
//   try {
//     const Products = await Product.find({}).populate("Category");

//     const totalProduct = await Product.countDocuments({});
//     res.status(200).json({ Products, totalProduct });
//   } catch (error) {
//     res
//       .status(500)
//       .json({ message: "Error getting products", error: error.message });
//   }
// };

module.exports.getProduct = async (req, res) => {
  try {
    const { role, countryId, branchId } = req.user;

    let filter = {};

    if (role === "superadmin") {
      // Superadmin sees everything
      filter = {};
    } else if (role === "countryadmin") {
      filter = {
        countryId,
      };
    } else {
      filter = {
        $or: [{ branchId: null }, { branchId }],
        countryId,
      };
    }

    const Products = await Product.find(filter)
      .populate("Category")
      .sort({ createdAt: -1 });

    const totalProduct = await Product.countDocuments(filter);

    res.status(200).json({
      Products,
      totalProduct,
    });
  } catch (error) {
    res.status(500).json({
      message: "Error getting products",
      error: error.message,
    });
  }
};

module.exports.RemoveProduct = async (req, res) => {
  try {
    const { productId } = req.params;
    const userId = req.user.userId;
    const userRole = req.user.role;
    const ipAddress = req.ip;
    const existingProduct = await Product.findById(productId).populate(
      "createdBy",
      "role",
    );
    if (!existingProduct) {
      return res.status(404).json({ message: "Product not found!" });
    }
    const creatorId = existingProduct.createdBy?._id?.toString();
    const creatorRole = existingProduct.createdBy?.role;
    const isOwner = creatorId && creatorId === userId?.toString();
    const canOverride = canOverrideOwner(userRole, creatorRole);
    if (!isOwner && !canOverride) {
      return res.status(403).json({
        message:
          "Access denied. You can only delete your own products or those created by lower roles.",
      });
    }

    const deletedProduct = await Product.findByIdAndDelete(productId);

    await logActivity({
      action: "Delete Product",
      description: `Product ${deletedProduct.name}" was deleted.`,
      entity: "product",
      entityId: deletedProduct._id,
      userId: userId,
      ipAddress: ipAddress,
    });

    res.status(200).json({ message: "Product deleted successfully" });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Error deleting product", error: error.message });
  }
};

module.exports.EditProduct = async (req, res) => {
  try {
    const { name, Category, Price, quantity, Desciption, dateAdded } = req.body;
    const { id } = req.params;
    const userId = req.user.userId;
    const userRole = req.user.role;
    const ipAddress = req.ip;
    if (!name || !Category || !Price) {
      return res.status(400).json({ message: "Required fields missing" });
    }

    const existingProduct = await Product.findById(id).populate(
      "createdBy",
      "role",
    );
    if (!existingProduct) {
      return res.status(404).json({ message: "Product not found." });
    }
    const creatorId = existingProduct.createdBy?._id?.toString();
    const creatorRole = existingProduct.createdBy?.role;
    const isOwner = creatorId && creatorId === userId?.toString();
    const canOverride = canOverrideOwner(userRole, creatorRole);
    if (!isOwner && !canOverride) {
      return res.status(403).json({
        message:
          "Access denied. You can only edit your own products or those created by lower roles.",
      });
    }

    const updatedProduct = await Product.findByIdAndUpdate(
      id,
      { name, Category, Price, quantity, Desciption, dateAdded },
      { new: true },
    );

    if (!updatedProduct) {
      return res.status(404).json({ message: "Product not found." });
    }

    await logActivity({
      action: "Update Product",
      description: `Product "${updatedProduct.name}" was updated.`,
      entity: "product",
      entityId: updatedProduct._id,
      userId,
      ipAddress,
    });

    res.status(200).json(updatedProduct);
  } catch (error) {
    console.error("Error updating product:", error);
    res
      .status(500)
      .json({ message: "Error updating product", error: error.message });
  }
};

module.exports.SearchProduct = async (req, res) => {
  try {
    const { query } = req.query;
    const { role, countryId, branchId } = req.user;
    if (!query) {
      return res.status(400).json({ message: "Query parameter is required" });
    }

    let scopeFilter = {};
    if (role === "superadmin") {
      scopeFilter = {};
    } else if (role === "countryadmin") {
      scopeFilter = { countryId };
    } else {
      scopeFilter = { $or: [{ branchId: null }, { branchId }], countryId };
    }

    const products = await Product.find({
      $or: [
        { name: { $regex: query, $options: "i" } },
        { Desciption: { $regex: query, $options: "i" } },

        { "Category.name": { $regex: query, $options: "i" } },
      ],
      ...scopeFilter,
    });

    res.json(products);
  } catch (error) {
    res
      .status(500)
      .json({ message: "Error finding product", error: error.message });
  }
};

module.exports.getTopProductsByQuantity = async (req, res) => {
  try {
    const { role, countryId, branchId } = req.user;
    let filter = {};
    if (role === "superadmin") {
      filter = {};
    } else if (role === "countryadmin") {
      filter = { countryId };
    } else {
      filter = { $or: [{ branchId: null }, { branchId }], countryId };
    }
    const topProducts = await Product.find(filter)
      .sort({ quantity: -1 })
      .limit(10);
    res.status(200).json({ success: true, topProducts });
  } catch (error) {
    res.status(500).json({
      message: "Error fetching products for chart",
      error: error.message,
    });
  }
};
